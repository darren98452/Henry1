import { INITIAL_WORDS } from '../constants';
import type { PracticeSession, Settings, UserData, Word, QuizQuestion, SwipeItem } from '../types';

// --- MOCK WORD BANK (Simulates a large database of words generated by an LLM) ---
const WORD_BANK: Word[] = [
    ...INITIAL_WORDS,
    { word: 'Prosaic', pronunciation: '/prəˈzeɪɪk/', definition: 'Dull, lacking in imagination and originality.', example: 'The prosaic nature of his poetry failed to inspire the readers.', synonyms: ['unimaginative', 'commonplace', 'humdrum'], difficulty: 'medium' },
    { word: 'Capricious', pronunciation: '/kəˈprɪʃəs/', definition: 'Given to sudden and unaccountable changes of mood or behavior.', example: 'The capricious weather made it difficult to plan the picnic.', synonyms: ['fickle', 'inconstant', 'mercurial'], difficulty: 'hard' },
    { word: 'Erudite', pronunciation: '/ˈɛrʊdaɪt/', definition: 'Having or showing great knowledge or learning.', example: 'The erudite professor delivered a fascinating lecture on ancient history.', synonyms: ['learned', 'scholarly', 'knowledgeable'], difficulty: 'medium' },
    { word: 'Anachronism', pronunciation: '/əˈnækrəˌnɪzəm/', definition: 'A thing belonging or appropriate to a period other than that in which it exists.', example: 'A smartphone in a movie set in the 1950s is a clear anachronism.', synonyms: ['misplacement', 'prolepsis', 'solecism'], difficulty: 'hard' },
    { word: 'Laconic', pronunciation: '/ləˈkɒnɪk/', definition: 'Using very few words.', example: 'His laconic reply suggested a lack of interest in the topic.', synonyms: ['brief', 'concise', 'terse'], difficulty: 'easy' },
    { word: 'Pulchritudinous', pronunciation: '/ˌpʌlkrɪˈtjuːdɪnəs/', definition: 'Having great physical beauty.', example: 'The pulchritudinous landscape was breathtaking.', synonyms: ['beautiful', 'gorgeous', 'lovely'], difficulty: 'hard' }
];


// --- MOCK DATABASE ---
let mockData: UserData = {
    words: INITIAL_WORDS.slice(0, 5), // User starts with a small subset of words
    bookmarkedWords: ['Serendipity'],
    quizStats: {
        totalCorrect: 15,
        totalAnswered: 18,
    },
    settings: {
        theme: 'lavender',
        userName: 'Learner',
    },
    friendIds: [2, 5, 9],
    practiceHistory: [],
};


// --- MOCK API FUNCTIONS ---
const api = {
    async getUserData(): Promise<UserData> {
        console.log("API: Fetching user data...");
        return new Promise(resolve => {
            setTimeout(() => {
                console.log("API: User data fetched.", mockData);
                resolve(JSON.parse(JSON.stringify(mockData)));
            }, 800);
        });
    },

    async generateNewWords(count: number): Promise<Word[]> {
        console.log(`API: Generating ${count} new words for user...`);
        return new Promise(resolve => {
            setTimeout(() => {
                const userWords = new Set(mockData.words.map(w => w.word));
                const newWords = WORD_BANK.filter(w => !userWords.has(w.word)).slice(0, count);
                mockData.words.push(...newWords);
                console.log("API: New words added.", newWords);
                resolve(JSON.parse(JSON.stringify(newWords)));
            }, 600);
        });
    },

    async recordInteraction(wordIdentifier: string, quality: number): Promise<Word> {
        console.log(`API: Recording interaction for ${wordIdentifier} with quality ${quality}`);
        return new Promise(resolve => {
            setTimeout(() => {
                const word = mockData.words.find(w => w.word === wordIdentifier)!;
                
                // Update stats
                mockData.quizStats.totalAnswered += 1;
                if (quality >= 3) mockData.quizStats.totalCorrect += 1;

                // Knowledge Tracing (SM-2) Logic now on the backend
                let srsData = word.srsData || {
                    lastReviewed: new Date().toISOString(), nextReview: new Date().toISOString(),
                    interval: 1, easeFactor: 2.5, repetition: 0,
                };
                srsData.lastReviewed = new Date().toISOString();

                if (quality < 3) {
                    srsData.repetition = 0;
                    srsData.interval = 1;
                    srsData.easeFactor = Math.max(1.3, srsData.easeFactor - 0.2);
                } else {
                    const newEaseFactor = srsData.easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
                    srsData.easeFactor = Math.max(1.3, newEaseFactor);
                    srsData.repetition += 1;
                    srsData.interval = srsData.repetition <= 2 ? (srsData.repetition === 1 ? 1 : 6) : Math.ceil(srsData.interval * srsData.easeFactor);
                }
                const nextReviewDate = new Date();
                nextReviewDate.setDate(nextReviewDate.getDate() + srsData.interval);
                srsData.nextReview = nextReviewDate.toISOString();

                word.srsData = srsData;
                console.log(`API: SRS data for ${word.word} updated.`, srsData);
                resolve(JSON.parse(JSON.stringify(word)));
            }, 400);
        });
    },

    async generateQuiz(words: Word[]): Promise<QuizQuestion[]> {
        console.log("API: Generating a quiz for words:", words.map(w => w.word));
        return new Promise(resolve => {
            setTimeout(() => {
                const questions = words.map(word => {
                    const distractors = WORD_BANK.filter(w => w.word !== word.word).sort(() => 0.5 - Math.random()).slice(0, 3);
                    const options = [word.word, ...distractors.map(d => d.word)].sort(() => 0.5 - Math.random());
                    return {
                        word: word.word,
                        definition: `What is the meaning of "${word.word}"?`,
                        options,
                        correctAnswer: word.word,
                        explanation: `"${word.word}" means "${word.definition}".`
                    };
                });
                console.log("API: Quiz generated.", questions);
                resolve(questions);
            }, 700);
        });
    },

    async generateSynonymPair(): Promise<SwipeItem> {
        console.log("API: Generating synonym pair...");
        return new Promise(resolve => {
            setTimeout(() => {
                const areSynonyms = Math.random() > 0.5;
                const word1 = WORD_BANK[Math.floor(Math.random() * WORD_BANK.length)];
                let word2;
                if (areSynonyms && word1.synonyms.length > 0) {
                    word2 = { word: word1.synonyms[0] };
                } else {
                    const otherWords = WORD_BANK.filter(w => w.word !== word1.word && !word1.synonyms.includes(w.word));
                    word2 = otherWords[Math.floor(Math.random() * otherWords.length)];
                }
                const pair = { word1: word1.word, word2: word2.word, areSynonyms };
                console.log("API: Pair generated.", pair);
                resolve(pair);
            }, 500);
        });
    },

    async toggleBookmark(wordIdentifier: string): Promise<string[]> {
         return new Promise(resolve => {
             setTimeout(() => {
                 const index = mockData.bookmarkedWords.indexOf(wordIdentifier);
                 if (index > -1) mockData.bookmarkedWords.splice(index, 1);
                 else mockData.bookmarkedWords.push(wordIdentifier);
                 resolve([...mockData.bookmarkedWords]);
             }, 300);
         });
    },

    async addPracticeSession(session: Omit<PracticeSession, 'id' | 'date'>): Promise<PracticeSession[]> {
         return new Promise(resolve => {
             setTimeout(() => {
                 const newSession: PracticeSession = { ...session, id: `${Date.now()}-${Math.random()}`, date: new Date().toISOString() };
                 mockData.practiceHistory = [newSession, ...mockData.practiceHistory].slice(0, 50);
                 resolve([...mockData.practiceHistory]);
             }, 400);
         });
    },
    async clearPracticeHistory(): Promise<PracticeSession[]> {
        return new Promise(resolve => { setTimeout(() => { mockData.practiceHistory = []; resolve([]); }, 500); });
    },
    async updateSettings(settings: Settings): Promise<Settings> {
        return new Promise(resolve => { setTimeout(() => { mockData.settings = settings; resolve({ ...mockData.settings }); }, 300); });
    },
    async updateFriends(friendIds: number[]): Promise<number[]> {
        return new Promise(resolve => { setTimeout(() => { mockData.friendIds = friendIds; resolve([...mockData.friendIds]); }, 300); });
    },
};

export default api;
